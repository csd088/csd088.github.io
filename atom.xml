<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[东方不败的个人博客]]></title>
  <link href="http://csd088.github.io/atom.xml" rel="self"/>
  <link href="http://csd088.github.io/"/>
  <updated>2018-09-03T13:55:20+08:00</updated>
  <id>http://csd088.github.io/</id>
  <author>
    <name><![CDATA[chenshengdong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ios键盘之数字键盘]]></title>
    <link href="http://csd088.github.io/blog/2018/09/03/iosjian-pan-zhi-shu-zi-jian-pan/"/>
    <updated>2018-09-03T13:41:05+08:00</updated>
    <id>http://csd088.github.io/blog/2018/09/03/iosjian-pan-zhi-shu-zi-jian-pan</id>
    <content type="html"><![CDATA[<p>经常要用到金额输入带小数点的键盘，都并不需要自定义，系统有提供带点的数字键盘。</p>

<!--more-->


<h3>配置</h3>

<p>field.keyboardType = UIKeyboardTypeNumberPad; 
这个只是纯数字键盘，无小数点。</p>

<p>field.keyboardType = UIKeyboardTypeDecimalPad 
这个只是纯数字键盘，有小数点。</p>

<h4><a name="fenced-code-block">金额输入限制两位小数</a></h4>

<p>代码</p>

<pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;
{
    //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反
    NSString * toBeString = [textField.text     stringByReplacingCharactersInRange:range withString:string];
     // 判断是否输入内容，或者用户点击的是键盘的删除按钮
     if (![string isEqualToString:@""]) {
            if ([textField isEqual:self.textField]) {
        // 小数点在字符串中的位置 第一个数字从0位置开始
                NSInteger dotLocation = [textField.text rangeOfString:@"."].location;
                if (dotLocation == NSNotFound &amp;&amp; range.location != 0) {
            //没有小数点,最大数值
                    if (range.location &gt;= 9){
                    NSLog(@"单笔金额不能超过亿位");
                    if ([string isEqualToString:@"."] &amp;&amp; range.location == 9) {
                        return YES;
                    }
                    return NO;
                }
            }
        //判断输入多个小数点,禁止输入多个小数点
            if (dotLocation != NSNotFound){
            if ([string isEqualToString:@"."])return NO;
        }
        //判断小数点后最多两位
        if (dotLocation != NSNotFound &amp;&amp; range.location &gt; dotLocation + 2) { return NO; }
        //判断总长度
            if (textField.text.length &gt; 11) {
                return NO;
            }
        }
    }
    return YES;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift闭包笔记]]></title>
    <link href="http://csd088.github.io/blog/2018/08/24/swiftbi-bao-bi-ji/"/>
    <updated>2018-08-24T15:57:39+08:00</updated>
    <id>http://csd088.github.io/blog/2018/08/24/swiftbi-bao-bi-ji</id>
    <content type="html"><![CDATA[<p>闭包(Closures)是自包含的功能代码块，可以在代码中使用或者用来作为参数传值。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 匿名函数比较相似。</p>

<!--more-->


<p>全局函数和嵌套函数其实就是特殊的闭包。
闭包的形式有：</p>

<table border = "1" align="center">
<tr>
<th>全局函数 </th>
<th>嵌套函数</th>
<th>闭包表达式 </th>
</tr>
<tr>
<td>有名字但是不能捕获任何值</td>
<td>有名字，也能捕获封闭函数内的值</td>
<td>无名闭包，使用轻量级语法，可以根据上下文环境捕获值</td>
</tr>
</table>


<p><br></p>

<p>Swift中的闭包有很多优化的地方:
根据上下文推断参数和返回值类型
从单行表达式闭包中隐式返回（也就是闭包体只有一行代码，可以省略return）
可以使用简化参数名，如$0, $1(从0开始，表示第i个参数&hellip;)
提供了尾随闭包语法(Trailing closure syntax)</p>

<h2>语法</h2>

<p>以下定义了一个接收参数并返回指定类型的闭包语法：</p>

<pre><code>{(parameters) -&gt; return type in
    statements
}
</code></pre>

<h2>实例</h2>

<pre><code>import Cocoa
let studname = { print("Swift 闭包实例。") }
studname()
</code></pre>

<p>以上程序执行输出结果为：</p>

<pre><code>Swift 闭包实例。
</code></pre>

<p>以下闭包形式接收两个参数并返回布尔值：</p>

<pre><code>{(Int, Int) -&gt; Bool in
    Statement1
    Statement 2
     ---
    Statement n
}
</code></pre>

<h2>实例</h2>

<pre><code>import Cocoa

let divide = {(val1: Int, val2: Int) -&gt; Int in 
    return val1 / val2 
}
let result = divide(200, 20)
print (result)
</code></pre>

<p>以上程序执行输出结果为：</p>

<pre><code>10
</code></pre>

<h2>闭包表达式</h2>

<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。 闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。</p>

<h3>sorted 方法</h3>

<p>Swift 标准库提供了名为 sorted(by:) 的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。</p>

<p>排序完成后，sorted(by:) 方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被 sorted(by:) 方法修改。
sorted(by:)方法需要传入两个参数：</p>

<p>  1、已知类型的数组</p>

<p>  2、闭包函数，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回 <strong>true</strong>，反之返回 <strong>false</strong>。</p>

<h3>实例</h3>

<pre><code>import Cocoa

let names = ["AT", "AE", "D", "S", "BE"]
// 使用普通函数(或内嵌函数)提供排序功能,闭包函数类型需为(String,   String) -&gt; Bool。
func backwards(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = names.sorted(by: backwards)
print(reversed)
</code></pre>

<p>以上程序执行输出结果为：</p>

<pre><code>["S", "D", "BE", "AT", "AE"]
</code></pre>

<p>如果第一个字符串 (s1) 大于第二个字符串 (s2)，backwards函数返回true，表示在新的数组中s1应该出现在s2前。 对于字符串中的字符来说，"大于" 表示 &ldquo;按照字母顺序较晚出现"。 这意味着字母"B"大于字母"A"，字符串"S"大于字符串"D"。 其将进行字母逆序排序，"AT"将会排在"AE"之前。</p>

<h3>参数名称缩写</h3>

<p>Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过$0,$1,$2来顺序调用闭包的参数。</p>

<h3>实例</h3>

<pre><code>import Cocoa
let names = ["AT", "AE", "D", "S", "BE"]
var reversed = names.sorted( by: { $0 &gt; $1 } )
print(reversed)
</code></pre>

<p>\$0和 \$1表示闭包中第一个和第二个String类型的参数。
以上程序执行输出结果为：</p>

<pre><code>["S", "D", "BE", "AT", "AE"]
</code></pre>

<p>如果你在闭包表达式中使用参数名称缩写, 您可以在闭包参数列表中省略对其定义, 并且对应参数名称缩写的类型会通过函数类型进行推断。<strong>in</strong> 关键字同样也可以被省略.</p>

<h3>运算符函数</h3>

<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。
Swift 的String类型定义了关于大于号 (>) 的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值。 而这正好与sort(_:)方法的第二个参数需要的函数类型相符合。 因此，您可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>

<pre><code>import Cocoa

let names = ["AT", "AE", "D", "S", "BE"]

var reversed = names.sorted(by: &gt;)
print(reversed)
</code></pre>

<p>以上程序执行输出结果为：</p>

<pre><code>["S", "D", "BE", "AT", "AE"]
</code></pre>

<h2>尾随闭包</h2>

<p>尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>

<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
 // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure({
  // 闭包主体部分
})

// 以下是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
 // 闭包主体部分
}
</code></pre>

<h3>实例</h3>

<pre><code>import Cocoa

let names = ["AT", "AE", "D", "S", "BE"]

//尾随闭包
var reversed = names.sorted() { $0 &gt; $1 }
print(reversed)
</code></pre>

<p>sort() 后的 { \$0 > \$1} 为尾随闭包。
以上程序执行输出结果为：</p>

<pre><code>["S", "D", "BE", "AT", "AE"]
</code></pre>

<p><mark>注意： 如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把()省略掉。reversed = names.sorted { \$0 > \$1 }</mark></p>

<h2>捕获值</h2>

<p>闭包可以在其定义的上下文中捕获常量或变量。
即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。
Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。
看这个例子：</p>

<pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
var runningTotal = 0
func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
return incrementor
}   
</code></pre>

<p>一个函数makeIncrementor ，它有一个Int型的参数amout, 并且它有一个外部参数名字forIncremet，意味着你调用的时候，必须使用这个外部名字。返回值是一个()-> Int的函数。
函数题内，声明了变量runningTotal 和一个函数incrementor。
incrementor函数并没有获取任何参数，但是在函数体内访问了runningTotal和amount变量。这是因为其通过捕获在包含它的函数体内已经存在的runningTotal和amount变量而实现。
由于没有修改amount变量，incrementor实际上捕获并存储了该变量的一个副本，而该副本随着incrementor一同被存储。
所以我们调用这个函数时会累加：</p>

<pre><code>import Cocoa

func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
var runningTotal = 0
func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)

// 返回的值为10
print(incrementByTen())

// 返回的值为20
print(incrementByTen())

// 返回的值为30
print(incrementByTen())
</code></pre>

<p>以上程序执行输出结果为：</p>

<pre><code>10
20
30
</code></pre>

<h2>闭包是引用类型</h2>

<p>上面的例子中，incrementByTen是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。
这是因为函数和闭包都是引用类型。
无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。 上面的例子中，incrementByTen指向闭包的引用是一个常量，而并非闭包内容本身。
这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>

<pre><code>let alsoIncrementByTen = incrementByTen

// 返回的值也为40
print(alsoIncrementByTen())
</code></pre>

<p>以上程序执行输出结果为：</p>

<pre><code>40
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[零基础在Mac上用Octopress和GitHub搭建个人博客]]></title>
    <link href="http://csd088.github.io/blog/2018/08/23/ling-ji-chu-zai-macshang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/"/>
    <updated>2018-08-23T14:03:40+08:00</updated>
    <id>http://csd088.github.io/blog/2018/08/23/ling-ji-chu-zai-macshang-yong-octopresshe-githubda-jian-ge-ren-bo-ke</id>
    <content type="html"><![CDATA[<p>本文主要是记录一个之前完全没接触过博客的新手，在Mac上使用<a href="http://octopress.org">Octopress</a>和GitHub搭建个人博客的经历。
本人资质笨拙，参考<a href="http://yulingtianxia.com/blog/2014/04/05/macosx10-dot-9shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/">玉令天下</a>、<a href="https://www.jianshu.com/u/c188a9c836b3">单刀土豆</a>、<a href="https://www.jianshu.com/p/37a6a63c21da">Vanbein</a>等大神的经验，花了差不多一天时间终于成功构建了一个简陋的个人博客。</p>

<!--more-->


<h2>环境搭建</h2>

<p>1、安装Ruby环境，安装RVM同时安装最新Ruby（已安装的可跳过）</p>

<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>2、安装完，查看Ruby版本</p>

<pre><code>ruby -v
</code></pre>

<p>3、如果你的 Ruby 版本不低于 2.3.0，可直接跳下一步进行安装 RubyGems。否则需要执行如下命令</p>

<pre><code>rvm install 2.5.1
rvm use 2.5.1
</code></pre>

<h2>安装Octopress</h2>

<p>1、将 Octopress 的项目 clone 到本地，终端执行如下命令：</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<p>2、安装完，进入octopress目录：</p>

<pre><code>cd octopress
</code></pre>

<p>3、然后执行（需科学上网）</p>

<pre><code>sudo gem install bundler
bundle install
</code></pre>

<p>4、安装默认主题</p>

<pre><code>rake install
</code></pre>

<p>5、预览效果，这个时候已经搭建好一个简单的Octopress博客了</p>

<pre><code>rake preview
</code></pre>

<p>然后打开浏览器输入 <a href="http://localhost:4000/">http://localhost:4000/</a>
正常结果会出现如下界面</p>

<p><img src="https://upload-images.jianshu.io/upload_images/635689-9a554909effc43fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="MacDown Screenshot" /></p>

<p><mark>本地预览过一次发现修改后再次执行预览命令无效解决办法</mark></p>

<p>终端输入</p>

<pre><code>    lsof -wni tcp:4000 #找到进程的PID值
    kill -9 PID值
</code></pre>

<p>现在就可以刷新本地预览了
。</p>

<h2>本地Octopress博客部署到GitHub上去</h2>

<h3>1、新建GitHub repositiry</h3>

<p>首先需要有个GitHub账号，没有的自行注册，登录GitHub后，新建<strong>GitHub repository</strong> ，项目名称（<strong>Repository name</strong>）命名格式为 <strong>username.github.io</strong> ，username 是你的 Github 用户名（或 organization name，这里和后面我们先不讨论 origanization）。例如我的用户名是 csd088，所以输入 csd088.github.io 即可。点击 <strong>Create repository</strong> 创建。</p>

<h3>2、配置GitHub Pages</h3>

<p>终端执行如下命令：</p>

<pre><code>cd octopress
rake setup_github_pages
</code></pre>

<p>该命令会要求我们输入 Github 仓库的 URL 。复制粘贴下我们新建仓库的 SSH 或 HTTPS URL 即可。（例如：<em>git@github.com:username/username.github.io.git</em>），注意此处有坑，若是新手，选择了SSH后面会出现要求配置SSH Key问题，可能会导致很麻烦,主要是需要配置<strong>publickey</strong> 之后才能提交到GitHub</p>

<p>不然提交的时候会提示：</p>

<pre><code>Permission denied (publickey).  fatal: Could not read from remote respository.
</code></pre>

<h3>配置publickey的方法</h3>

<p>1、生成新的ssh key这里会提示要不要rewrite，键入y，还有提示输入passPhrase，输入空格即可</p>

<pre><code>cd ~/.ssh
ssh-keygen
</code></pre>

<p>2、测试一下连接</p>

<pre><code>ssh -T -v git@github.com
</code></pre>

<p>不出意外的话这里会报错，最后几行提示信息如下：</p>

<pre><code>debug1: Offering RSA public key: yourpath/.ssh/id_rsa   debug1: Authentications that can continue: publickey    debug1: Trying private key:yourpath/.ssh/id_dsa debug1: Trying private key:yourpath/.ssh/id_ecdsa   debug1: Trying private key:yourpath/.ssh/id_ed25519 debug1: No more authentication methods to try.  Permission denied (publickey).
</code></pre>

<p>提示信息表明路径 yourpath/.ssh下id_rsa文件存在，并且提供public key，然而无法和网站中的ssh-key匹配上。于是程序转而寻找yourpath/.ssh路径下的id_dsa文件，id_ecdsa文件，id_ed25519文件，看它们是不是能提供新的public key。
查看一下yourpath/.ssh，会发现下面根本不存在id_dsa，id_ecdsa，id_ed25519文件。 出错的原因其实在于步骤4更新了本地的ssh key，然而网站上的ssh key还为旧值，所以匹配不上，就报错Permission denied (publickey)</p>

<p>3、打开yourpath/.ssh/id_rsa.pub（.pub为公钥文件，id_rsa为私钥文件），复制里面的内容。 </p>

<p>4、打开<a href="https://github.com/settings/profile">https://github.com/settings/profile</a>，在SSH key那栏选择New SSH Key，并将复制内容拷贝到其中，选择保存。</p>

<p>5、再次测试$ ssh -T git@github.com，提示 </p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>You've successfully authenticated, but GitHub does not provide shell access.
</span></code></pre></td></tr></table></div></figure>


<p><strong>错误排查完毕 ^_^</strong></p>

<p>到目前为止已经将 Octopress 生成的静态站点与 GitHub 进行绑定了</p>

<h2>创建文章</h2>

<p>终端执行指令：</p>

<pre><code>rake new_post["title"]    #title为你的文章名，可随意更改
</code></pre>

<p>生成的新文章在source/_post/目录下，文件名构成为时间和标题的拼音。我们可以用Markdown编辑器对文章进行修改。
打开新建的 markdown 文件（我目前用的 MacDown 打开），会发现头文件有如下内容（千万不要删除这段信息）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---
</span><span class='line'>layout: post             #post代表是一篇博文
</span><span class='line'>title: "hello world"
</span><span class='line'>date: 2015-10-14 19:59:22 +0800
</span><span class='line'>comments: true         #是否允许评论
</span><span class='line'>categories:             #分类
</span><span class='line'>---
</span><span class='line'>
</span><span class='line'>//这边编写简介
</span><span class='line'>&lt;!--more--&gt;   //这个以下的内容只有详情页才能看到
</span><span class='line'>//这半边编写正文</span></code></pre></td></tr></table></div></figure>


<p>终端用指定软件打开文件命令</p>

<pre><code>open -a /Applications/指定程序　指定文件（文件夹）
</code></pre>

<p><mark>不知道软件所在的路径，可以直接把软件拖到终端就可以获取到</mark></p>

<p>正文写完后，终端执行如下指令即可生成静态站点，：</p>

<pre><code>rake generate
</code></pre>

<p>如果你想预览本地的站点，可以执行终端指令：</p>

<pre><code>rake preview
</code></pre>

<p>此时，可以使用浏览器打开 localhost:4000 查看效果。如果没有问题可以将静态站点同步到 GitHub 远程仓库中，终端执行指令：</p>

<pre><code>rake deploy
</code></pre>

<p>你会发现我们的静态站点已经被 push 到 GitHub仓库的 master 分支上。稍等几分钟，访问博客地址 username.github.io ，就会发现你的个人博客站的第一篇blog已创建成功了。</p>

<p>如果你还想把自己的本地资源文件（如Markdown文件等内容）也同步到 GitHub 中，可以执行以下指令：</p>

<pre><code>git add .
git commit -m "comment"  #comment可随意更改
git push origin source
</code></pre>

<p>这样我们的资源文件就会同步到 GitHub 的 source 分支了。</p>

<h2>主要用到的几个命令解释</h2>

<pre><code>rake new_post[’title’]     # 新建博文文件
rake generate              # 将编辑好的博文生成网页
rake preview               # 提交前可以进行本地预览
rake deploy                # 将博文部署到Github上
git add .                       # 保存缓存文件
git commit -m '注释'       # 提交本地更改的文件并注释
git push origin source     # 将源文件push到Github的source分支
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TabbleView的Cell中有Textfield、TextView时防止键盘遮挡]]></title>
    <link href="http://csd088.github.io/blog/2018/08/23/tabbleviewde-cellzhong-you-textfield,-textviewshi-fang-zhi-jian-pan-zhe-dang/"/>
    <updated>2018-08-23T09:36:34+08:00</updated>
    <id>http://csd088.github.io/blog/2018/08/23/tabbleviewde-cellzhong-you-textfield,-textviewshi-fang-zhi-jian-pan-zhe-dang</id>
    <content type="html"><![CDATA[<p>TableView的Cell中有TextField、TextView时防止键盘遮挡小技巧</p>

<!--more-->


<p>直接上代码后面再解释</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> - (UITableView *)tableView {
</span><span class='line'>      if (!_tableView) {
</span><span class='line'>          UITableViewController* tvc=[[UITableViewController    alloc] initWithStyle:UITableViewStylePlain];
</span><span class='line'>          [self addChildViewController:tvc];
</span><span class='line'>          [tvc.view setFrame:self.view.frame];
</span><span class='line'>          _tableView=tvc.tableView;
</span><span class='line'>          _tableView.delegate = self;
</span><span class='line'>          _tableView.dataSource = self;
</span><span class='line'>          _tableView.separatorStyle =   UITableViewCellSeparatorStyleSingleLine;
</span><span class='line'>          }
</span><span class='line'>      return _tableView;
</span><span class='line'>  }
</span><span class='line'>          </span></code></pre></td></tr></table></div></figure>


<p>直接在初始化TableView的时候用系统的UITableViewController替换掉，因为UITableViewController中的tableview已经做了可以自适应键盘高度来改变tableview的额外高度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://csd088.github.io/blog/2018/08/22/first-post/"/>
    <updated>2018-08-22T15:03:43+08:00</updated>
    <id>http://csd088.github.io/blog/2018/08/22/first-post</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
